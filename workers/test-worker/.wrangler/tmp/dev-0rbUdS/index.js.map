{
  "version": 3,
  "sources": ["../bundle-V9nyQY/checked-fetch.js", "../bundle-V9nyQY/strip-cf-connecting-ip-header.js", "../../../../shared/utils.ts", "../../../../shared/db-helpers.ts", "../../../../email-worker/src/handlers/signup.ts", "../../../../auth-worker/src/jwt.ts", "../../../../auth-worker/src/handlers/login.ts", "../../../../auth-worker/src/handlers/verify.ts", "../../../../progress-worker/src/handlers/update.ts", "../../../../progress-worker/src/handlers/get.ts", "../../../../progress-worker/src/handlers/analytics.ts", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-V9nyQY/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-V9nyQY/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/.wrangler/tmp/dev-0rbUdS",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "// Shared utility functions for Cloudflare Workers\n\nimport { LogEntry, ErrorResponse, Env } from './types';\n\n// Generate UUID v4\nexport function generateUUID(): string {\n  return crypto.randomUUID();\n}\n\n// Structured logging\nexport function log(\n  level: LogEntry['level'], \n  message: string, \n  context?: any, \n  requestId?: string\n): void {\n  const entry: LogEntry = {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    context,\n    requestId\n  };\n  \n  console.log(JSON.stringify(entry));\n}\n\n// Error response helper\nexport function createErrorResponse(\n  error: string, \n  status: number = 500, \n  code?: string, \n  details?: any\n): Response {\n  const errorResponse: ErrorResponse = {\n    error,\n    code,\n    details\n  };\n  \n  return Response.json(errorResponse, { status });\n}\n\n// Success response helper\nexport function createSuccessResponse(data: any, status: number = 200): Response {\n  return Response.json(data, { status });\n}\n\n// CORS headers\nexport const CORS_HEADERS = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n};\n\n// Add CORS headers to response\nexport function addCorsHeaders(response: Response): Response {\n  Object.entries(CORS_HEADERS).forEach(([key, value]) => {\n    response.headers.set(key, value);\n  });\n  return response;\n}\n\n// Handle OPTIONS request\nexport function handleOptions(): Response {\n  return new Response(null, { headers: CORS_HEADERS });\n}\n\n// Validate email format\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n// Sanitize input\nexport function sanitizeString(input: string): string {\n  return input.trim().toLowerCase();\n}\n\n// Generate discount code\nexport function generateDiscountCode(): string {\n  return `CREATOR10-${crypto.randomUUID().substring(0, 8).toUpperCase()}`;\n}\n\n// Retry logic for operations\nexport async function withRetry<T>(\n  operation: () => Promise<T>, \n  maxRetries: number = 3,\n  delay: number = 100\n): Promise<T> {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await operation();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));\n    }\n  }\n  throw new Error('Max retries exceeded');\n}\n\n// Extract request ID from headers\nexport function getRequestId(request: Request): string {\n  return request.headers.get('cf-ray') || generateUUID();\n}\n\n// Get client IP\nexport function getClientIP(request: Request): string {\n  return request.headers.get('CF-Connecting-IP') || \n         request.headers.get('X-Forwarded-For') || \n         'unknown';\n}\n\n// Get user agent\nexport function getUserAgent(request: Request): string {\n  return request.headers.get('User-Agent') || 'unknown';\n}\n\n// Validate required fields\nexport function validateRequired(data: any, fields: string[]): void {\n  for (const field of fields) {\n    if (!data[field]) {\n      throw new Error(`${field} is required`);\n    }\n  }\n}\n\n// Parse JSON safely\nexport async function parseJSON(request: Request): Promise<any> {\n  try {\n    return await request.json();\n  } catch (error) {\n    throw new Error('Invalid JSON in request body');\n  }\n}\n\n// Track analytics event\nexport async function trackEvent(\n  event: string, \n  properties: any, \n  env: Env,\n  email?: string\n): Promise<void> {\n  try {\n    const analyticsData = {\n      event,\n      properties,\n      timestamp: Date.now(),\n      email,\n      ...properties\n    };\n    \n    // Store in KV for batch processing\n    await env.ANALYTICS_KV.put(\n      `event:${Date.now()}:${generateUUID()}`,\n      JSON.stringify(analyticsData),\n      { expirationTtl: 86400 } // 24 hours\n    );\n  } catch (error) {\n    log('error', 'Failed to track analytics event', { error: error.message, event });\n  }\n}\n\n// Performance tracker\nexport class PerformanceTracker {\n  private startTime: number;\n  \n  constructor() {\n    this.startTime = Date.now();\n  }\n  \n  mark(label: string): number {\n    const duration = Date.now() - this.startTime;\n    log('info', `Performance: ${label} took ${duration}ms`);\n    return duration;\n  }\n}\n\n// Rate limiting helper\nexport async function checkRateLimit(\n  key: string, \n  limit: number, \n  window: number, \n  env: Env\n): Promise<boolean> {\n  const now = Date.now();\n  const windowStart = now - window * 1000;\n  \n  // Get current count\n  const current = await env.CACHE_KV.get(`rate_limit:${key}`, 'json') as { count: number, timestamp: number } | null;\n  \n  if (!current || current.timestamp < windowStart) {\n    // Reset or initialize\n    await env.CACHE_KV.put(\n      `rate_limit:${key}`, \n      JSON.stringify({ count: 1, timestamp: now }),\n      { expirationTtl: window }\n    );\n    return true;\n  }\n  \n  if (current.count >= limit) {\n    return false;\n  }\n  \n  // Increment count\n  await env.CACHE_KV.put(\n    `rate_limit:${key}`, \n    JSON.stringify({ count: current.count + 1, timestamp: current.timestamp }),\n    { expirationTtl: window }\n  );\n  \n  return true;\n}\n", "// Database helper functions for Cloudflare D1\n\nimport { \n  EmailSubscriber, \n  ReadingProgress, \n  UserSession, \n  ContentAccessLog,\n  Env \n} from './types';\nimport { generateUUID, withRetry } from './utils';\n\n// Email Subscriber operations\nexport class EmailSubscriberDB {\n  constructor(private env: Env) {}\n\n  async findByEmail(email: string): Promise<EmailSubscriber | null> {\n    return withRetry(async () => {\n      const result = await this.env.DB.prepare(\n        'SELECT * FROM email_subscribers WHERE email = ?'\n      ).bind(email).first();\n      \n      return result as EmailSubscriber | null;\n    });\n  }\n\n  async create(data: {\n    email: string;\n    firstName?: string;\n    lastName?: string;\n    discountCode?: string;\n  }): Promise<EmailSubscriber> {\n    return withRetry(async () => {\n      const id = generateUUID();\n      const now = new Date().toISOString();\n      \n      await this.env.DB.prepare(`\n        INSERT INTO email_subscribers \n        (id, email, first_name, last_name, discount_code, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        id,\n        data.email,\n        data.firstName || null,\n        data.lastName || null,\n        data.discountCode || null,\n        now,\n        now\n      ).run();\n\n      return this.findByEmail(data.email) as Promise<EmailSubscriber>;\n    });\n  }\n\n  async updateEmailsSent(email: string): Promise<void> {\n    return withRetry(async () => {\n      const now = new Date().toISOString();\n      \n      await this.env.DB.prepare(`\n        UPDATE email_subscribers \n        SET emails_sent = emails_sent + 1, \n            last_email_sent = ?,\n            updated_at = ?\n        WHERE email = ?\n      `).bind(now, now, email).run();\n    });\n  }\n\n  async updateAccess(email: string, hasAccess: boolean, hasPurchased?: boolean): Promise<void> {\n    return withRetry(async () => {\n      const now = new Date().toISOString();\n      \n      if (hasPurchased !== undefined) {\n        await this.env.DB.prepare(`\n          UPDATE email_subscribers \n          SET has_access = ?, has_purchased = ?, updated_at = ?\n          WHERE email = ?\n        `).bind(hasAccess ? 1 : 0, hasPurchased ? 1 : 0, now, email).run();\n      } else {\n        await this.env.DB.prepare(`\n          UPDATE email_subscribers \n          SET has_access = ?, updated_at = ?\n          WHERE email = ?\n        `).bind(hasAccess ? 1 : 0, now, email).run();\n      }\n    });\n  }\n}\n\n// Reading Progress operations\nexport class ReadingProgressDB {\n  constructor(private env: Env) {}\n\n  async findByEmail(email: string): Promise<ReadingProgress[]> {\n    return withRetry(async () => {\n      const result = await this.env.DB.prepare(\n        'SELECT * FROM reading_progress WHERE email = ? ORDER BY chapter_number'\n      ).bind(email).all();\n      \n      return result.results as ReadingProgress[];\n    });\n  }\n\n  async findByEmailAndChapter(email: string, chapterNumber: number): Promise<ReadingProgress | null> {\n    return withRetry(async () => {\n      const result = await this.env.DB.prepare(\n        'SELECT * FROM reading_progress WHERE email = ? AND chapter_number = ?'\n      ).bind(email, chapterNumber).first();\n      \n      return result as ReadingProgress | null;\n    });\n  }\n\n  async upsert(data: {\n    email: string;\n    chapterNumber: number;\n    completed?: boolean;\n    timeSpent?: number;\n    videosWatched?: string[];\n    quizzesPassed?: string[];\n  }): Promise<ReadingProgress> {\n    return withRetry(async () => {\n      const id = generateUUID();\n      const now = new Date().toISOString();\n      \n      // Convert arrays to JSON strings\n      const videosWatchedJson = JSON.stringify(data.videosWatched || []);\n      const quizzesPassedJson = JSON.stringify(data.quizzesPassed || []);\n      \n      await this.env.DB.prepare(`\n        INSERT INTO reading_progress \n        (id, email, chapter_number, completed, time_spent, videos_watched, quizzes_passed, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ON CONFLICT(email, chapter_number) DO UPDATE SET\n          completed = excluded.completed,\n          time_spent = excluded.time_spent,\n          videos_watched = excluded.videos_watched,\n          quizzes_passed = excluded.quizzes_passed,\n          updated_at = excluded.updated_at\n      `).bind(\n        id,\n        data.email,\n        data.chapterNumber,\n        data.completed ? 1 : 0,\n        data.timeSpent || 0,\n        videosWatchedJson,\n        quizzesPassedJson,\n        now,\n        now\n      ).run();\n\n      return this.findByEmailAndChapter(data.email, data.chapterNumber) as Promise<ReadingProgress>;\n    });\n  }\n\n  async getCompletionStats(email: string): Promise<{\n    totalChapters: number;\n    completedChapters: number;\n    totalTimeSpent: number;\n  }> {\n    return withRetry(async () => {\n      const result = await this.env.DB.prepare(`\n        SELECT \n          COUNT(*) as total_chapters,\n          SUM(CASE WHEN completed = 1 THEN 1 ELSE 0 END) as completed_chapters,\n          SUM(time_spent) as total_time_spent\n        FROM reading_progress \n        WHERE email = ?\n      `).bind(email).first();\n      \n      return {\n        totalChapters: result?.total_chapters || 0,\n        completedChapters: result?.completed_chapters || 0,\n        totalTimeSpent: result?.total_time_spent || 0\n      };\n    });\n  }\n}\n\n// User Session operations\nexport class UserSessionDB {\n  constructor(private env: Env) {}\n\n  async create(userEmail: string, sessionToken: string, expiresAt: Date): Promise<UserSession> {\n    return withRetry(async () => {\n      const id = generateUUID();\n      const now = new Date().toISOString();\n      \n      await this.env.DB.prepare(`\n        INSERT INTO user_sessions \n        (id, user_email, session_token, expires_at, created_at)\n        VALUES (?, ?, ?, ?, ?)\n      `).bind(\n        id,\n        userEmail,\n        sessionToken,\n        expiresAt.toISOString(),\n        now\n      ).run();\n\n      return {\n        id,\n        user_email: userEmail,\n        session_token: sessionToken,\n        expires_at: expiresAt.toISOString(),\n        created_at: now\n      };\n    });\n  }\n\n  async findByToken(sessionToken: string): Promise<UserSession | null> {\n    return withRetry(async () => {\n      const result = await this.env.DB.prepare(\n        'SELECT * FROM user_sessions WHERE session_token = ? AND expires_at > ?'\n      ).bind(sessionToken, new Date().toISOString()).first();\n      \n      return result as UserSession | null;\n    });\n  }\n\n  async deleteByToken(sessionToken: string): Promise<void> {\n    return withRetry(async () => {\n      await this.env.DB.prepare(\n        'DELETE FROM user_sessions WHERE session_token = ?'\n      ).bind(sessionToken).run();\n    });\n  }\n\n  async deleteExpired(): Promise<void> {\n    return withRetry(async () => {\n      await this.env.DB.prepare(\n        'DELETE FROM user_sessions WHERE expires_at <= ?'\n      ).bind(new Date().toISOString()).run();\n    });\n  }\n}\n\n// Content Access Log operations\nexport class ContentAccessLogDB {\n  constructor(private env: Env) {}\n\n  async log(data: {\n    email: string;\n    chapterNumber?: number;\n    accessType: 'view' | 'download' | 'share';\n    ipAddress?: string;\n    userAgent?: string;\n  }): Promise<void> {\n    return withRetry(async () => {\n      const id = generateUUID();\n      const now = new Date().toISOString();\n      \n      await this.env.DB.prepare(`\n        INSERT INTO content_access_logs \n        (id, email, chapter_number, access_type, ip_address, user_agent, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        id,\n        data.email,\n        data.chapterNumber || null,\n        data.accessType,\n        data.ipAddress || null,\n        data.userAgent || null,\n        now\n      ).run();\n    });\n  }\n\n  async getAccessStats(email: string): Promise<{\n    totalViews: number;\n    totalDownloads: number;\n    totalShares: number;\n    lastAccess: string | null;\n  }> {\n    return withRetry(async () => {\n      const result = await this.env.DB.prepare(`\n        SELECT \n          SUM(CASE WHEN access_type = 'view' THEN 1 ELSE 0 END) as total_views,\n          SUM(CASE WHEN access_type = 'download' THEN 1 ELSE 0 END) as total_downloads,\n          SUM(CASE WHEN access_type = 'share' THEN 1 ELSE 0 END) as total_shares,\n          MAX(created_at) as last_access\n        FROM content_access_logs \n        WHERE email = ?\n      `).bind(email).first();\n      \n      return {\n        totalViews: result?.total_views || 0,\n        totalDownloads: result?.total_downloads || 0,\n        totalShares: result?.total_shares || 0,\n        lastAccess: result?.last_access || null\n      };\n    });\n  }\n}\n", "// Email signup handler\n\nimport { Env, EmailSignupRequest, EmailSignupResponse } from '../../../shared/types';\nimport { EmailSubscriberDB } from '../../../shared/db-helpers';\nimport { \n  parseJSON, \n  isValidEmail, \n  createErrorResponse, \n  createSuccessResponse,\n  log,\n  getRequestId,\n  generateDiscountCode,\n  checkRateLimit,\n  trackEvent\n} from '../../../shared/utils';\n\nexport async function handleEmailSignup(request: Request, env: Env): Promise<Response> {\n  const requestId = getRequestId(request);\n  \n  try {\n    // Rate limiting - 3 signups per minute per IP\n    const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';\n    const rateLimitKey = `signup:${clientIP}`;\n    \n    const isAllowed = await checkRateLimit(rateLimitKey, 3, 60, env);\n    if (!isAllowed) {\n      log('warn', 'Rate limit exceeded for signup', { clientIP }, requestId);\n      return createErrorResponse('Too many signup attempts. Please try again later.', 429);\n    }\n\n    // Parse and validate request\n    const data = await parseJSON(request) as EmailSignupRequest;\n    \n    if (!data.email || !isValidEmail(data.email)) {\n      log('warn', 'Invalid email in signup request', { email: data.email }, requestId);\n      return createErrorResponse('Valid email is required', 400);\n    }\n\n    const email = data.email.toLowerCase().trim();\n    const firstName = data.firstName?.trim();\n    const lastName = data.lastName?.trim();\n    \n    // Check if user already exists\n    const emailDB = new EmailSubscriberDB(env);\n    const existingUser = await emailDB.findByEmail(email);\n\n    if (existingUser) {\n      log('info', 'User already exists, returning existing data', { email }, requestId);\n      \n      const response: EmailSignupResponse = {\n        success: true,\n        message: \"Welcome back! You already have access.\",\n        user: {\n          email: existingUser.email,\n          first_name: existingUser.first_name,\n          has_access: existingUser.has_access,\n          has_purchased: existingUser.has_purchased\n        },\n        hasAccess: existingUser.has_access,\n        discountCode: existingUser.discount_code\n      };\n\n      return createSuccessResponse(response);\n    }\n\n    // Generate discount code\n    const discountCode = generateDiscountCode();\n\n    // Create new subscriber\n    const newUser = await emailDB.create({\n      email,\n      firstName,\n      lastName,\n      discountCode\n    });\n\n    // Queue welcome email\n    try {\n      await env.EMAIL_QUEUE.send({\n        type: 'welcome',\n        email,\n        firstName,\n        discountCode\n      });\n      \n      log('info', 'Welcome email queued', { email }, requestId);\n    } catch (queueError) {\n      log('error', 'Failed to queue welcome email', { \n        email, \n        error: queueError.message \n      }, requestId);\n      // Don't fail the signup if email queueing fails\n    }\n\n    // Track signup event\n    await trackEvent('user_signup', {\n      email,\n      firstName,\n      hasDiscount: !!discountCode,\n      source: 'web'\n    }, env, email);\n\n    const response: EmailSignupResponse = {\n      success: true,\n      message: \"Welcome! You now have access to the first 7 chapters.\",\n      user: {\n        email: newUser.email,\n        first_name: newUser.first_name,\n        has_access: newUser.has_access,\n        has_purchased: newUser.has_purchased\n      },\n      hasAccess: true,\n      discountCode\n    };\n\n    log('info', 'User signup successful', { email }, requestId);\n    return createSuccessResponse(response);\n\n  } catch (error) {\n    log('error', 'Email signup error', { \n      error: error.message,\n      stack: error.stack \n    }, requestId);\n    \n    return createErrorResponse('Signup failed. Please try again.', 500);\n  }\n}\n", "// JWT utilities using Cloudflare Web Crypto API\n\nimport { JWTPayload } from '../../shared/types';\n\nexport async function generateJWT(payload: JWTPayload, secret: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['sign']\n  );\n\n  const header = { alg: 'HS256', typ: 'JWT' };\n  const encodedHeader = btoa(JSON.stringify(header)).replace(/=/g, '');\n  const encodedPayload = btoa(JSON.stringify(payload)).replace(/=/g, '');\n  \n  const data = encoder.encode(`${encodedHeader}.${encodedPayload}`);\n  const signature = await crypto.subtle.sign('HMAC', key, data);\n  const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n  \n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n}\n\nexport async function verifyJWT(token: string, secret: string): Promise<JWTPayload> {\n  const [header, payload, signature] = token.split('.');\n  \n  if (!header || !payload || !signature) {\n    throw new Error('Invalid token format');\n  }\n  \n  const encoder = new TextEncoder();\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['verify']\n  );\n\n  const data = encoder.encode(`${header}.${payload}`);\n  const signatureBuffer = Uint8Array.from(\n    atob(signature.replace(/-/g, '+').replace(/_/g, '/')), \n    c => c.charCodeAt(0)\n  );\n  \n  const isValid = await crypto.subtle.verify('HMAC', key, signatureBuffer, data);\n  \n  if (!isValid) {\n    throw new Error('Invalid token signature');\n  }\n  \n  const decodedPayload = JSON.parse(atob(payload)) as JWTPayload;\n  \n  // Check expiration\n  if (decodedPayload.exp && decodedPayload.exp < Math.floor(Date.now() / 1000)) {\n    throw new Error('Token expired');\n  }\n  \n  return decodedPayload;\n}\n\nexport function createJWTPayload(\n  email: string,\n  type: 'magic_link' | 'session' = 'session',\n  expirationMinutes: number = 60 * 24 * 7, // 7 days default\n  additionalData?: Partial<JWTPayload>\n): JWTPayload {\n  const now = Math.floor(Date.now() / 1000);\n  \n  return {\n    email,\n    type,\n    exp: now + (expirationMinutes * 60),\n    iat: now,\n    ...additionalData\n  };\n}\n", "// Magic link login handler\n\nimport { Env, MagicLinkRequest, MagicLinkResponse } from '../../../shared/types';\nimport { EmailSubscriberDB } from '../../../shared/db-helpers';\nimport { \n  parseJSON, \n  isValidEmail, \n  createErrorResponse, \n  createSuccessResponse,\n  log,\n  getRequestId,\n  checkRateLimit\n} from '../../../shared/utils';\nimport { generateJWT, createJWTPayload } from '../jwt';\n\nexport async function handleMagicLinkLogin(request: Request, env: Env): Promise<Response> {\n  const requestId = getRequestId(request);\n  \n  try {\n    // Rate limiting - 5 requests per minute per IP\n    const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';\n    const rateLimitKey = `magic_link:${clientIP}`;\n    \n    const isAllowed = await checkRateLimit(rateLimitKey, 5, 60, env);\n    if (!isAllowed) {\n      log('warn', 'Rate limit exceeded for magic link', { clientIP }, requestId);\n      return createErrorResponse('Too many requests. Please try again later.', 429);\n    }\n\n    // Parse and validate request\n    const data = await parseJSON(request) as MagicLinkRequest;\n    \n    if (!data.email || !isValidEmail(data.email)) {\n      log('warn', 'Invalid email in magic link request', { email: data.email }, requestId);\n      return createErrorResponse('Valid email is required', 400);\n    }\n\n    const email = data.email.toLowerCase().trim();\n    \n    // Check if user exists\n    const emailDB = new EmailSubscriberDB(env);\n    const user = await emailDB.findByEmail(email);\n\n    if (!user) {\n      log('warn', 'Magic link requested for non-existent user', { email }, requestId);\n      return createErrorResponse('User not found. Please sign up first.', 404);\n    }\n\n    // Generate magic link token (15 minutes expiry)\n    const payload = createJWTPayload(email, 'magic_link', 15);\n    const token = await generateJWT(payload, env.JWT_SECRET);\n\n    // Queue magic link email\n    try {\n      await env.EMAIL_QUEUE.send({\n        type: 'magic_link',\n        email,\n        firstName: user.first_name,\n        token,\n        loginUrl: `${env.FRONTEND_URL}/auth/verify?token=${token}`\n      });\n      \n      log('info', 'Magic link email queued', { email }, requestId);\n    } catch (queueError) {\n      log('error', 'Failed to queue magic link email', { \n        email, \n        error: queueError.message \n      }, requestId);\n      \n      return createErrorResponse('Failed to send magic link. Please try again.', 500);\n    }\n\n    const response: MagicLinkResponse = {\n      success: true,\n      message: 'Magic link sent to your email'\n    };\n\n    log('info', 'Magic link sent successfully', { email }, requestId);\n    return createSuccessResponse(response);\n\n  } catch (error) {\n    log('error', 'Magic link login error', { \n      error: error.message,\n      stack: error.stack \n    }, requestId);\n    \n    return createErrorResponse('Login failed. Please try again.', 500);\n  }\n}\n", "// Token verification handler\n\nimport { Env, VerifyTokenRequest, AuthResponse } from '../../../shared/types';\nimport { EmailSubscriberDB, UserSessionDB } from '../../../shared/db-helpers';\nimport { \n  parseJSON, \n  createErrorResponse, \n  createSuccessResponse,\n  log,\n  getRequestId,\n  generateUUID\n} from '../../../shared/utils';\nimport { verifyJWT, generateJWT, createJWTPayload } from '../jwt';\n\nexport async function handleVerifyToken(request: Request, env: Env): Promise<Response> {\n  const requestId = getRequestId(request);\n  \n  try {\n    // Parse and validate request\n    const data = await parseJSON(request) as VerifyTokenRequest;\n    \n    if (!data.token) {\n      log('warn', 'Missing token in verify request', {}, requestId);\n      return createErrorResponse('Token is required', 400);\n    }\n\n    // Verify the magic link token\n    let payload;\n    try {\n      payload = await verifyJWT(data.token, env.JWT_SECRET);\n    } catch (jwtError) {\n      log('warn', 'Invalid or expired token', { error: jwtError.message }, requestId);\n      return createErrorResponse('Invalid or expired token', 401);\n    }\n\n    // Check if it's a magic link token\n    if (payload.type !== 'magic_link') {\n      log('warn', 'Invalid token type for verification', { type: payload.type }, requestId);\n      return createErrorResponse('Invalid token type', 401);\n    }\n\n    // Get user details\n    const emailDB = new EmailSubscriberDB(env);\n    const user = await emailDB.findByEmail(payload.email);\n\n    if (!user) {\n      log('warn', 'User not found during token verification', { email: payload.email }, requestId);\n      return createErrorResponse('User not found', 404);\n    }\n\n    // Create a new session token\n    const sessionPayload = createJWTPayload(\n      user.email,\n      'session',\n      60 * 24 * 7, // 7 days\n      {\n        userId: user.id,\n        hasAccess: user.has_access,\n        hasPurchased: user.has_purchased\n      }\n    );\n    \n    const sessionToken = await generateJWT(sessionPayload, env.JWT_SECRET);\n\n    // Store session in database\n    const sessionDB = new UserSessionDB(env);\n    const expiresAt = new Date(sessionPayload.exp * 1000);\n    \n    try {\n      await sessionDB.create(user.email, sessionToken, expiresAt);\n      log('info', 'Session created successfully', { email: user.email }, requestId);\n    } catch (sessionError) {\n      log('error', 'Failed to create session', { \n        email: user.email, \n        error: sessionError.message \n      }, requestId);\n      // Continue anyway, session token is still valid\n    }\n\n    // Cache user session in KV for faster access\n    try {\n      const sessionData = {\n        userId: user.id,\n        email: user.email,\n        hasAccess: user.has_access,\n        hasPurchased: user.has_purchased,\n        createdAt: Date.now()\n      };\n\n      await env.SESSIONS_KV.put(\n        `session:${sessionToken}`,\n        JSON.stringify(sessionData),\n        { expirationTtl: 7 * 24 * 60 * 60 } // 7 days\n      );\n    } catch (kvError) {\n      log('warn', 'Failed to cache session in KV', { \n        email: user.email, \n        error: kvError.message \n      }, requestId);\n      // Continue anyway, session is still valid\n    }\n\n    const response: AuthResponse = {\n      success: true,\n      token: sessionToken,\n      user: {\n        email: user.email,\n        firstName: user.first_name,\n        hasAccess: user.has_access,\n        hasPurchased: user.has_purchased\n      }\n    };\n\n    log('info', 'Token verified and session created', { email: user.email }, requestId);\n    return createSuccessResponse(response);\n\n  } catch (error) {\n    log('error', 'Token verification error', { \n      error: error.message,\n      stack: error.stack \n    }, requestId);\n    \n    return createErrorResponse('Verification failed. Please try again.', 500);\n  }\n}\n", "// Progress update handler\n\nimport { Env, ProgressUpdateRequest, ProgressResponse } from '../../../shared/types';\nimport { ReadingProgressDB, ContentAccessLogDB } from '../../../shared/db-helpers';\nimport { \n  parseJSON, \n  isValidEmail, \n  createErrorResponse, \n  createSuccessResponse,\n  log,\n  getRequestId,\n  getClientIP,\n  getUserAgent,\n  trackEvent\n} from '../../../shared/utils';\n\nexport async function handleProgressUpdate(request: Request, env: Env): Promise<Response> {\n  const requestId = getRequestId(request);\n  \n  try {\n    // Parse and validate request\n    const data = await parseJSON(request) as ProgressUpdateRequest;\n    \n    if (!data.email || !isValidEmail(data.email)) {\n      log('warn', 'Invalid email in progress update', { email: data.email }, requestId);\n      return createErrorResponse('Valid email is required', 400);\n    }\n\n    if (!data.chapterNumber || data.chapterNumber < 1) {\n      log('warn', 'Invalid chapter number', { chapterNumber: data.chapterNumber }, requestId);\n      return createErrorResponse('Valid chapter number is required', 400);\n    }\n\n    const email = data.email.toLowerCase().trim();\n    \n    // Update reading progress\n    const progressDB = new ReadingProgressDB(env);\n    const updatedProgress = await progressDB.upsert({\n      email,\n      chapterNumber: data.chapterNumber,\n      completed: data.completed,\n      timeSpent: data.timeSpent,\n      videosWatched: data.videosWatched,\n      quizzesPassed: data.quizzesPassed\n    });\n\n    // Log content access\n    const accessLogDB = new ContentAccessLogDB(env);\n    await accessLogDB.log({\n      email,\n      chapterNumber: data.chapterNumber,\n      accessType: 'view',\n      ipAddress: getClientIP(request),\n      userAgent: getUserAgent(request)\n    });\n\n    // Track analytics events\n    if (data.completed) {\n      await trackEvent('chapter_completed', {\n        email,\n        chapterNumber: data.chapterNumber,\n        timeSpent: data.timeSpent\n      }, env, email);\n    }\n\n    if (data.videosWatched && data.videosWatched.length > 0) {\n      await trackEvent('videos_watched', {\n        email,\n        chapterNumber: data.chapterNumber,\n        videoCount: data.videosWatched.length,\n        videos: data.videosWatched\n      }, env, email);\n    }\n\n    if (data.quizzesPassed && data.quizzesPassed.length > 0) {\n      await trackEvent('quizzes_completed', {\n        email,\n        chapterNumber: data.chapterNumber,\n        quizCount: data.quizzesPassed.length,\n        quizzes: data.quizzesPassed\n      }, env, email);\n    }\n\n    // Cache updated progress\n    try {\n      const cacheKey = `progress:${email}`;\n      const allProgress = await progressDB.findByEmail(email);\n      \n      await env.CACHE_KV.put(\n        cacheKey, \n        JSON.stringify(allProgress),\n        { expirationTtl: 300 } // 5 minutes\n      );\n    } catch (cacheError) {\n      log('warn', 'Failed to cache progress', { \n        email, \n        error: cacheError.message \n      }, requestId);\n    }\n\n    const response: ProgressResponse = {\n      success: true,\n      progress: [updatedProgress]\n    };\n\n    log('info', 'Progress updated successfully', { \n      email, \n      chapterNumber: data.chapterNumber,\n      completed: data.completed\n    }, requestId);\n    \n    return createSuccessResponse(response);\n\n  } catch (error) {\n    log('error', 'Progress update error', { \n      error: error.message,\n      stack: error.stack \n    }, requestId);\n    \n    return createErrorResponse('Failed to update progress. Please try again.', 500);\n  }\n}\n", "// Progress retrieval handler\n\nimport { Env, ProgressResponse } from '../../../shared/types';\nimport { ReadingProgressDB } from '../../../shared/db-helpers';\nimport { \n  isValidEmail, \n  createErrorResponse, \n  createSuccessResponse,\n  log,\n  getRequestId\n} from '../../../shared/utils';\n\nexport async function handleGetProgress(request: Request, env: Env): Promise<Response> {\n  const requestId = getRequestId(request);\n  \n  try {\n    const url = new URL(request.url);\n    const email = url.searchParams.get('email');\n    \n    if (!email || !isValidEmail(email)) {\n      log('warn', 'Invalid email in progress get request', { email }, requestId);\n      return createErrorResponse('Valid email is required', 400);\n    }\n\n    const normalizedEmail = email.toLowerCase().trim();\n    \n    // Try to get from cache first\n    let progress;\n    try {\n      const cacheKey = `progress:${normalizedEmail}`;\n      const cached = await env.CACHE_KV.get(cacheKey, 'json');\n      \n      if (cached) {\n        log('info', 'Progress retrieved from cache', { email: normalizedEmail }, requestId);\n        \n        const response: ProgressResponse = {\n          success: true,\n          progress: cached\n        };\n        \n        return createSuccessResponse(response);\n      }\n    } catch (cacheError) {\n      log('warn', 'Failed to get progress from cache', { \n        email: normalizedEmail, \n        error: cacheError.message \n      }, requestId);\n    }\n\n    // Get from database\n    const progressDB = new ReadingProgressDB(env);\n    progress = await progressDB.findByEmail(normalizedEmail);\n\n    // Cache the result\n    try {\n      const cacheKey = `progress:${normalizedEmail}`;\n      await env.CACHE_KV.put(\n        cacheKey, \n        JSON.stringify(progress),\n        { expirationTtl: 300 } // 5 minutes\n      );\n    } catch (cacheError) {\n      log('warn', 'Failed to cache progress', { \n        email: normalizedEmail, \n        error: cacheError.message \n      }, requestId);\n    }\n\n    const response: ProgressResponse = {\n      success: true,\n      progress\n    };\n\n    log('info', 'Progress retrieved successfully', { \n      email: normalizedEmail,\n      progressCount: progress.length\n    }, requestId);\n    \n    return createSuccessResponse(response);\n\n  } catch (error) {\n    log('error', 'Progress get error', { \n      error: error.message,\n      stack: error.stack \n    }, requestId);\n    \n    return createErrorResponse('Failed to retrieve progress. Please try again.', 500);\n  }\n}\n", "// Progress analytics handler\n\nimport { Env } from '../../../shared/types';\nimport { ReadingProgressDB, ContentAccessLogDB } from '../../../shared/db-helpers';\nimport { \n  isValidEmail, \n  createErrorResponse, \n  createSuccessResponse,\n  log,\n  getRequestId\n} from '../../../shared/utils';\n\nexport async function handleProgressAnalytics(request: Request, env: Env): Promise<Response> {\n  const requestId = getRequestId(request);\n  \n  try {\n    const url = new URL(request.url);\n    const email = url.searchParams.get('email');\n    \n    if (!email || !isValidEmail(email)) {\n      log('warn', 'Invalid email in analytics request', { email }, requestId);\n      return createErrorResponse('Valid email is required', 400);\n    }\n\n    const normalizedEmail = email.toLowerCase().trim();\n    \n    // Get completion stats\n    const progressDB = new ReadingProgressDB(env);\n    const completionStats = await progressDB.getCompletionStats(normalizedEmail);\n    \n    // Get access stats\n    const accessLogDB = new ContentAccessLogDB(env);\n    const accessStats = await accessLogDB.getAccessStats(normalizedEmail);\n    \n    // Calculate additional metrics\n    const completionRate = completionStats.totalChapters > 0 \n      ? (completionStats.completedChapters / completionStats.totalChapters) * 100 \n      : 0;\n    \n    const averageTimePerChapter = completionStats.completedChapters > 0\n      ? completionStats.totalTimeSpent / completionStats.completedChapters\n      : 0;\n\n    // Get detailed progress for streak calculation\n    const allProgress = await progressDB.findByEmail(normalizedEmail);\n    const currentStreak = calculateReadingStreak(allProgress);\n    \n    const analytics = {\n      completion: {\n        totalChapters: completionStats.totalChapters,\n        completedChapters: completionStats.completedChapters,\n        completionRate: Math.round(completionRate * 100) / 100,\n        totalTimeSpent: completionStats.totalTimeSpent,\n        averageTimePerChapter: Math.round(averageTimePerChapter)\n      },\n      engagement: {\n        totalViews: accessStats.totalViews,\n        totalDownloads: accessStats.totalDownloads,\n        totalShares: accessStats.totalShares,\n        lastAccess: accessStats.lastAccess,\n        currentStreak: currentStreak\n      },\n      progress: allProgress.map(p => ({\n        chapterNumber: p.chapter_number,\n        completed: p.completed,\n        timeSpent: p.time_spent,\n        videosWatched: JSON.parse(p.videos_watched || '[]').length,\n        quizzesPassed: JSON.parse(p.quizzes_passed || '[]').length,\n        lastUpdated: p.updated_at\n      }))\n    };\n\n    log('info', 'Analytics retrieved successfully', { \n      email: normalizedEmail,\n      completionRate,\n      totalChapters: completionStats.totalChapters\n    }, requestId);\n    \n    return createSuccessResponse(analytics);\n\n  } catch (error) {\n    log('error', 'Analytics error', { \n      error: error.message,\n      stack: error.stack \n    }, requestId);\n    \n    return createErrorResponse('Failed to retrieve analytics. Please try again.', 500);\n  }\n}\n\nfunction calculateReadingStreak(progress: any[]): number {\n  if (progress.length === 0) return 0;\n  \n  // Sort by chapter number\n  const sortedProgress = progress\n    .filter(p => p.completed)\n    .sort((a, b) => a.chapter_number - b.chapter_number);\n  \n  if (sortedProgress.length === 0) return 0;\n  \n  // Find the longest consecutive streak\n  let maxStreak = 1;\n  let currentStreak = 1;\n  \n  for (let i = 1; i < sortedProgress.length; i++) {\n    if (sortedProgress[i].chapter_number === sortedProgress[i - 1].chapter_number + 1) {\n      currentStreak++;\n      maxStreak = Math.max(maxStreak, currentStreak);\n    } else {\n      currentStreak = 1;\n    }\n  }\n  \n  return maxStreak;\n}\n", "// Unified Test Worker - Combines all functionality for testing\n// This demonstrates that all the individual workers work correctly\n\nimport { Env } from '../../shared/types';\nimport { handleOptions, addCorsHeaders, log, getRequestId } from '../../shared/utils';\n\n// Import handlers from individual workers\nimport { handleEmailSignup } from '../../email-worker/src/handlers/signup';\nimport { handleMagicLinkLogin } from '../../auth-worker/src/handlers/login';\nimport { handleVerifyToken } from '../../auth-worker/src/handlers/verify';\nimport { handleProgressUpdate } from '../../progress-worker/src/handlers/update';\nimport { handleGetProgress } from '../../progress-worker/src/handlers/get';\nimport { handleProgressAnalytics } from '../../progress-worker/src/handlers/analytics';\n\nexport default {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    const requestId = getRequestId(request);\n    const url = new URL(request.url);\n    const path = url.pathname;\n    const method = request.method;\n\n    log('info', 'Test worker request', { \n      method, \n      path, \n      userAgent: request.headers.get('User-Agent'),\n      ip: request.headers.get('CF-Connecting-IP')\n    }, requestId);\n\n    // Handle CORS preflight\n    if (method === 'OPTIONS') {\n      return handleOptions();\n    }\n\n    try {\n      let response: Response;\n\n      // Route to appropriate handler\n      switch (true) {\n        // Email routes\n        case path === '/email/signup' && method === 'POST':\n          response = await handleEmailSignup(request, env);\n          break;\n        \n        // Auth routes\n        case path === '/auth/magic-link' && method === 'POST':\n          response = await handleMagicLinkLogin(request, env);\n          break;\n        \n        case path === '/auth/verify' && method === 'POST':\n          response = await handleVerifyToken(request, env);\n          break;\n        \n        // Progress routes\n        case path === '/progress' && method === 'POST':\n          response = await handleProgressUpdate(request, env);\n          break;\n        \n        case path === '/progress' && method === 'GET':\n          response = await handleGetProgress(request, env);\n          break;\n        \n        case path === '/progress/analytics' && method === 'GET':\n          response = await handleProgressAnalytics(request, env);\n          break;\n        \n        // Health check\n        case path === '/health' && method === 'GET':\n          response = await handleHealthCheck(env);\n          break;\n        \n        // Test endpoints\n        case path === '/test/full-journey' && method === 'POST':\n          response = await handleFullJourneyTest(request, env);\n          break;\n        \n        case path === '/test/database' && method === 'GET':\n          response = await handleDatabaseTest(env);\n          break;\n        \n        default:\n          log('warn', 'Test worker route not found', { method, path }, requestId);\n          response = new Response(JSON.stringify({\n            error: 'Not Found',\n            message: 'The requested endpoint does not exist',\n            availableEndpoints: [\n              'POST /email/signup',\n              'POST /auth/magic-link',\n              'POST /auth/verify',\n              'POST /progress',\n              'GET /progress',\n              'GET /progress/analytics',\n              'GET /health',\n              'POST /test/full-journey',\n              'GET /test/database'\n            ]\n          }), { \n            status: 404,\n            headers: { 'Content-Type': 'application/json' }\n          });\n      }\n\n      // Add CORS headers\n      response = addCorsHeaders(response);\n      \n      log('info', 'Test worker response', { \n        status: response.status,\n        method,\n        path\n      }, requestId);\n\n      return response;\n\n    } catch (error) {\n      log('error', 'Test worker error', { \n        error: error.message,\n        stack: error.stack,\n        method,\n        path\n      }, requestId);\n      \n      const errorResponse = new Response(\n        JSON.stringify({ \n          error: 'Internal server error',\n          requestId \n        }), \n        { \n          status: 500,\n          headers: { 'Content-Type': 'application/json' }\n        }\n      );\n      \n      return addCorsHeaders(errorResponse);\n    }\n  },\n};\n\nasync function handleHealthCheck(env: Env): Promise<Response> {\n  const healthChecks = {\n    worker: { status: 'healthy' },\n    database: { status: 'unknown' },\n    timestamp: new Date().toISOString()\n  };\n\n  // Check database\n  try {\n    await env.DB.prepare('SELECT 1').first();\n    healthChecks.database.status = 'healthy';\n  } catch (error) {\n    healthChecks.database.status = 'error';\n  }\n\n  const overallStatus = Object.values(healthChecks).every(check => \n    typeof check === 'object' && check.status === 'healthy'\n  ) ? 'healthy' : 'degraded';\n\n  return new Response(JSON.stringify({\n    status: overallStatus,\n    checks: healthChecks,\n    version: '1.0.0'\n  }), {\n    status: overallStatus === 'healthy' ? 200 : 503,\n    headers: { 'Content-Type': 'application/json' }\n  });\n}\n\nasync function handleDatabaseTest(env: Env): Promise<Response> {\n  try {\n    // Test database connectivity and schema\n    const tables = await env.DB.prepare(`\n      SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'\n    `).all();\n\n    const testResults = {\n      tablesFound: tables.results.map(t => t.name),\n      expectedTables: ['email_subscribers', 'reading_progress', 'user_sessions', 'content_access_logs'],\n      schemaValid: false,\n      sampleData: {}\n    };\n\n    // Check if all expected tables exist\n    testResults.schemaValid = testResults.expectedTables.every(table => \n      testResults.tablesFound.includes(table)\n    );\n\n    // Get sample data counts\n    if (testResults.schemaValid) {\n      for (const table of testResults.expectedTables) {\n        try {\n          const count = await env.DB.prepare(`SELECT COUNT(*) as count FROM ${table}`).first();\n          testResults.sampleData[table] = count.count;\n        } catch (error) {\n          testResults.sampleData[table] = `Error: ${error.message}`;\n        }\n      }\n    }\n\n    return new Response(JSON.stringify({\n      success: true,\n      database: testResults\n    }), {\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n  } catch (error) {\n    return new Response(JSON.stringify({\n      success: false,\n      error: error.message\n    }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n}\n\nasync function handleFullJourneyTest(request: Request, env: Env): Promise<Response> {\n  try {\n    const testEmail = `test-${Date.now()}@example.com`;\n    const results = [];\n\n    // Step 1: Email signup\n    const signupRequest = new Request(request.url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        email: testEmail,\n        firstName: 'Test',\n        lastName: 'User'\n      })\n    });\n\n    const signupResponse = await handleEmailSignup(signupRequest, env);\n    const signupData = await signupResponse.json();\n    \n    results.push({\n      step: 'email_signup',\n      success: signupResponse.status === 200,\n      data: signupData\n    });\n\n    if (signupResponse.status !== 200) {\n      return new Response(JSON.stringify({\n        success: false,\n        message: 'Email signup failed',\n        results\n      }), {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n\n    // Step 2: Update progress\n    const progressRequest = new Request(request.url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        email: testEmail,\n        chapterNumber: 1,\n        completed: true,\n        timeSpent: 300,\n        videosWatched: ['video1'],\n        quizzesPassed: ['quiz1']\n      })\n    });\n\n    const progressResponse = await handleProgressUpdate(progressRequest, env);\n    const progressData = await progressResponse.json();\n    \n    results.push({\n      step: 'progress_update',\n      success: progressResponse.status === 200,\n      data: progressData\n    });\n\n    // Step 3: Get progress\n    const getProgressUrl = new URL(request.url);\n    getProgressUrl.searchParams.set('email', testEmail);\n    \n    const getProgressRequest = new Request(getProgressUrl.toString(), {\n      method: 'GET'\n    });\n\n    const getProgressResponse = await handleGetProgress(getProgressRequest, env);\n    const getProgressData = await getProgressResponse.json();\n    \n    results.push({\n      step: 'get_progress',\n      success: getProgressResponse.status === 200,\n      data: getProgressData\n    });\n\n    // Step 4: Get analytics\n    const analyticsUrl = new URL(request.url);\n    analyticsUrl.pathname = '/progress/analytics';\n    analyticsUrl.searchParams.set('email', testEmail);\n    \n    const analyticsRequest = new Request(analyticsUrl.toString(), {\n      method: 'GET'\n    });\n\n    const analyticsResponse = await handleProgressAnalytics(analyticsRequest, env);\n    const analyticsData = await analyticsResponse.json();\n    \n    results.push({\n      step: 'get_analytics',\n      success: analyticsResponse.status === 200,\n      data: analyticsData\n    });\n\n    const allSuccessful = results.every(result => result.success);\n\n    return new Response(JSON.stringify({\n      success: allSuccessful,\n      message: allSuccessful ? 'Full journey test completed successfully' : 'Some steps failed',\n      testEmail,\n      results\n    }), {\n      status: allSuccessful ? 200 : 500,\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n  } catch (error) {\n    return new Response(JSON.stringify({\n      success: false,\n      error: error.message,\n      stack: error.stack\n    }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n}\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/src/index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/.wrangler/tmp/bundle-V9nyQY/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/.wrangler/tmp/bundle-V9nyQY/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/theeskapeum/S2F-STUDIO/Colorful_E-Book_Creation/workers/test-worker/.wrangler/tmp/bundle-V9nyQY/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["response", "response"]
}
